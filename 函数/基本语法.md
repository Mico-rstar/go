## Go 函数基本语法
```Go
func 函数名(参数) 返回值类型
```

## 特性
### 函数作为类型
```Go
/// 声明func() 类型的切片
var funcs []func()  
```

### 返回值具名
可以给返回值取名
```Go
func pow() (result float64) {
    
}
```
具名的返回值，可以直接写return，但不推荐
```Go
func add(a, b int) (sum int) {
    sum := a + b 
    return  // 合法的，会自动返回sum
}
```



### 多返回值
```Go
func divide(a, b float64) (result float64, err error) {
    if b == 0 {
        return nil, errors.New("除0错误")
    }
    return a / b
}
```

### 多参数
...int 的行为和[]int类似
```Go
func accumulate(vals ...int) int{
    sum := 0
    for _, v := range vals {
        sum += v
    }
    return sum
}
```

### 匿名函数
```Go
accumulate := func (vals...int) int {
    sum := 0
    for _, v := range vals {
        sum += v
    }
    return sum
}
```
计算平均值优雅写法
```Go
s := []int{1, 2, 3, 4, 5}
mean := func (vals []int) int {
    sum := 0
    for _, v := range vals {
        sum += v
    }
    return sum / len(vals)
}(s)
```
#### 匿名函数的捕获行为
匿名函数以 **引用语义** 捕获当前作用域下的变量
```Go
func main() {
    a := 1
    f := func () {
        // 此处捕获作用域中a的引用
        a = 2
    }
    fmt.Println(a)  // 2
}
```
迭代变量捕获行为(go 1.22前行为)
```Go
// 1.22 版本前的行为
var funcs []func()
for i := 0; i < 3; i++ {
    funcs = append(funcs, func ()  {
        // 捕获迭代变量i
        fmt.Println(i)
    })
}
for _, f := range funcs {
    f()
}
/*  3
 *  3
 *  3
 */
```
这里会输出反直觉行为主要原因是i在迭代中是被重用的，由于闭包中式引用捕获语义，三个函数引用的i是一样的
在1.22版本后，该行为已被变更
```go
/*  0
 *  1
 *  2
 */
```


## defer
defer是推迟的意思，在go中的语义就是推迟函数执行
```Go
// 语法形式
defer f()
```

```Go
func f() {
    defer func() {
        fmt.Println("被defer执行")
    }()
    fmt.Println("normal")
}
// normal
// 被defer执行
```
defer常用来做资源(socket, mutex, file)释放，错误恢复

骚操作：使用defer修改返回值
```Go
func Num2String(n int) (result string) {
	defer func ()  {
		result = fmt.Sprintf("( %s )", result)
	}()
	return fmt.Sprintf("%d", n)
}
// 没有defer    Num2String(2) -> 2
// 有defer      Num2String(2) -> ( 2 )
```

## panic
panic用来处理可以预料，但难以处理的运行时错误，直接中断程序
常写在逻辑上程序不应该运行到的地方
```go
func PanicTest(i int) {
	switch i {
	case 1:
		fmt.Println(1)
	case 2:
		fmt.Println(2)
	default:
		panic("unexpected arguments")
	}
}
```


## recover
recover函数可以捕获运行时抛出的panic，避免程序直接崩溃
```Go
func PanicTest() {
    defer func ()  {
        // 处理panic
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    panic("unexpected")
}
```
recover 函数可以捕获函数调用链上的panic
```Go
func PanicFunc() {
    panic("unexpected")
}
func PanicTest() {
    defer func ()  {
        // 处理panic
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    PanicFunc()
}
```
可以有选择性recover
```Go
func soleTitle(doc *html.Node) (title string, err error) {
    type bailout struct{}
    defer func() {
        switch p := recover(); p {
        case nil:       // no panic
        case bailout{}: // "expected" panic
            err = fmt.Errorf("multiple title elements")
        default:
            panic(p) // unexpected panic; carry on panicking
        }
    }()
    // ...
}
```



