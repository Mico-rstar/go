### 接口本质
[[interface的本质]]


### 接口定义
接口其实就是一种类型，所以使用下面的类型定义语法来定义
```go
type MyInterface interface {

}
```


### 值接收者和类型接收者陷阱
考虑有以下队列接口
```go
type Queue[T any] interface {
	// Element access
	Front() (*T, error) 
	Back() (*T, error)
	Empty() bool
	Len() int
	Cap() int
	Push(T)
	Pop()
}
```
通过以下工厂函数获得一个实例
```go
func New[T any](ranges ...T) Queue[T] {
	sl := make([]T, len(ranges))
	copy(sl, ranges)
	return SimpleQueue[T]{sl}
}
```
如果SimpleQueue[T]中所有接口方法都是 **值接收者** ，那么使用这个工厂函数没有问题
但是考虑以下！！！
```go
// Push和Pop要修改内部值，必须使用指针接收者
func (q *SimpleQueue[T]) Push(t T) {
	q.inner = append(q.inner, t)
}

func (q *SimpleQueue[T]) Pop() {
	if len(q.inner) >= 1 {
		q.inner = q.inner[1:]
	}
}
```
这时候工厂函数必须改成将指针类型赋值给接口类型返回值
```go
func New[T any](ranges ...T) Queue[T] {
	sl := make([]T, len(ranges))
	copy(sl, ranges)
	return &SimpleQueue[T]{sl}      // 必须返回指针
}
```
这是基于以下规则：
- 如果接口中的方法都是值接收者，那么值类型和指针类型都能满足接口
- 如果接口中有任何方法是指针接收者，那么只有指针类型才能满足接口




