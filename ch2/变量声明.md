### 变量声明方式
```go
// var 变量名 类型 = 表达式
var s string
var i, j, k int

// 类型推导
var b, f, s = true, 2.3. "four" // bool, float64, string

// 匹配多个返回值
var f, err = os.Open(name)

// 函数内部可以使用简短变量声明
freq := rand.Float64() * 3.0
t := 0.0
```


### 简短声明的细节
相同作用域下进行重复声明，那么声明变成赋值行为
```go
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```

简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：
```go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables

```

### 指针特性
go指针基本行为与c一致

#### 返回局部变量安全
```go
var p = f()

func f() *int {
    v := 1
    return &v
}

```

#### 对go指针的理解
每次声明一个指针，都会对原来的变量增加一个引用，在变量的所有引用没有被完全释放前，其不会被gc释放，这也解释了为什么go可以返回局部变量指针


### new
```go
p := new(int)   // 指向匿名int类型变量，p是 *int 类型
fmt.Println(*p) // 0
```
#### 不可把new关键字类比c++中的new
```go
// 完全等价
func newInt() *int {
    return new(int)
}
func newInt() *int {
    var p int 
    return &p
}
```
c++中的new是堆内存分配原语，但go的new仅仅是变量分配的一个语法糖，也就是说用new关键字和普通声明并无区别，最终变量是被分配到堆上还是栈上由编译器决定
大体的规则是逃逸分析，如果变量生命周期有可能超出当前作用域，那么要分配到堆上，对应情况如下：
1. 函数返回局部变量
2. 局部变量被闭包捕获
3. 发送到channel
4. 大对象

### 变量生命周期
#### 全局变量
包一级的变量，生命周期与函数一致，是全局数据区的变量，不受gc管理
**使用一个全局指针指向一个堆上的变量，将会导致该变量生命周期延长**

#### 局部变量
gc回收变量的时机：从每个包级变量到当前运行函数的每个局部变量开始，通过指针或引用路径遍历，是否可以找到该变量，如果路径不可达，那么gc会认为是可释放的




